#!/usr/bin/env python

import sys
sys.path.append("/home/miles/Data/Work/MRes/project/lineage-app/lineage/lineage")
from lineage_lib import track
from analysis_lib import colourmap
import glob
import matplotlib.pyplot as plt
from matplotlib import gridspec
import scipy.misc
import scipy.ndimage
import scipy.signal
import scipy.stats
import numpy as np
import json
import datetime
import operator
import seaborn as sns
import os
import random
import string
import hashlib
import xlwt

# PX_UM = 0.12254  # 1px in um for 63x objective on WF2


class SpotTimeLapse(object):
    def __init__(self, t, p, i, l):
        self.id = hashlib.sha1("".join([
            random.choice(
                string.ascii_letters + string.digits
            ) for x in range(40)
        ]).encode("utf8")).hexdigest()
        self.timing = [t]
        if p < 0:
            # bottom pole
            self.POLE = -1
        else:
            self.POLE = 1
        self.positions = [p]
        self.intensity = [i]
        self.lengths = [l]

    def spots(self, adjust=True):
        if adjust:
            return np.array([
                self.timing,
                self.POLE * np.array(self.positions),
                self.intensity
            ]).T
        else:
            return np.array([
                self.timing,
                self.positions,
                self.intensity
            ]).T

    def len(self):
        return np.array(self.lengths)

    def last(self):
        return np.array([
            self.timing[-1], self.positions[-1], self.intensity[-1]
        ])

    def append(self, t, p, i, l):
        self.timing.append(t)
        self.positions.append(p)
        self.intensity.append(i)
        self.lengths.append(l)

    def __iadd__(self, other):
        self.timing.append(other[0])
        self.positions.append(other[1])
        self.intensity.append(other[2])
        self.lengths.append(other[3])

    def __len__(self):
        return len(self.lengths)


def deaxis(ax=None):
    if not ax:
        ax = plt.gca()
    ax.axis("off")


def despine(ax=None, keep=0):
    if not ax:
        ax = plt.gca()
    ax.spines["right"].set_color("none")
    ax.spines["top"].set_color("none")
    if keep == 1:
        ax.xaxis.set_ticks_position("bottom")
        ax.yaxis.set_ticks_position("left")
    elif keep == 0:
        ax.spines["left"].set_color("none")
        ax.spines["bottom"].set_color("none")
        ax.xaxis.set_ticks_position("none")
        ax.yaxis.set_ticks_position("none")


class Analysis(track.Lineage):
    MEAN = 1
    SUM = 2
    MAX = 3

    def __init__(self, debug, method=MEAN):
        self.debug = debug
        self.method = method
        track.Lineage.__init__(self)

    def apply_alignments(self):
        f = 0
        for align in self.alignment:
            try:
                cells = self.frames[f].cells
            except IndexError:
                break
            for c in cells:
                c.mesh = c.mesh - [
                    align[1], align[0], align[1], align[0]
                ]
            f += 1

    def _gettimestamp(self, day, time, *args):
        return datetime.datetime.strptime(
            "{0} {1}".format(day, time),
            "%d.%m.%y %H:%M"
        )

    def _timediff(self, day, time, t0):
        t1 = self._gettimestamp(day, time)
        td = t1 - t0
        s = td.days * 24 * 60 * 60
        s += td.seconds
        m = s // 60
        return m

    def get_timings(self, t0=False):
        timing_data = json.loads(open("timings.json").read())
        timings = timing_data["timings"]
        self.T = []
        if "start" in timing_data:
            t0 = self._gettimestamp(*timing_data["start"])
        else:
            t0 = self._gettimestamp(*timings[0])
        for d1, t1, frames in timings:
            sm = self._timediff(d1, t1, t0)
            for _ in range(frames):
                self.T.append(sm)
                sm += timing_data["pass_delay"]

    def process_fluor(self, img):
        # Gaussian smoothing to denoise
        img = self.denoise(img)
        return img

    def denoise(self, img):
        out = scipy.ndimage.gaussian_filter(img, 2)
        return out

    def get_fluor_for_rib(self, data, mesh):
        f, f_denoise, f2, f2_denoise = data
        xs_l, xs_r, ys_l, ys_r = mesh
        i = 0
        F = []  # average fluor along each mesh 'rib'
        F_unsmoothed = []

        F2 = []
        F2_unsmoothed = []

        while i < xs_l.shape[0]:
            H = int(np.sqrt(
                (ys_r[i] - ys_l[i]) ** 2 +
                (xs_r[i] - xs_l[i]) ** 2
            )) + 1
            x = np.linspace(
                xs_l[i], xs_r[i], H
            )
            y = np.linspace(
                ys_l[i], ys_r[i], H
            )
            z = scipy.ndimage.map_coordinates(
                f_denoise, np.vstack((y, x))
            )
            z_unsmoothed = scipy.ndimage.map_coordinates(
                f, np.vstack((y, x))
            )
            z2 = scipy.ndimage.map_coordinates(
                f2_denoise, np.vstack((y, x))
            )
            z2_unsmoothed = scipy.ndimage.map_coordinates(
                f2, np.vstack((y, x))
            )

            if self.method == self.MEAN:
                F.append(z.mean())
                F_unsmoothed.append(z_unsmoothed.mean())
                F2.append(z2.mean())
                F2_unsmoothed.append(z2_unsmoothed.mean())
            elif self.method == self.SUM:
                F.append(z.sum())
                F_unsmoothed.append(z_unsmoothed.sum())
                F2.append(z2.sum())
                F2_unsmoothed.append(z2_unsmoothed.sum())
            elif self.method == self.MAX:
                F.append(z.max())
                F_unsmoothed.append(z_unsmoothed.max())
                F2.append(z2.max())
                F2_unsmoothed.append(z2_unsmoothed.max())
            i += 1
        return F, F_unsmoothed, F2, F2_unsmoothed

    def peak_dist(self, x, l):
        if x < l:
            return x
        else:
            return l - x

        # _p = lambda x: if x > len(F) // 2: return len(F) - x else return x

    def get_spots(self, cell, orientation=True):
        frame_idx = cell.frame - 1
        xs_l = cell.mesh[:, 0]
        ys_l = cell.mesh[:, 1]
        xs_r = cell.mesh[:, 2]
        ys_r = cell.mesh[:, 3]

        if not orientation:
            xs_l = xs_l[::-1]
            ys_l = ys_l[::-1]
            xs_r = xs_r[::-1]
            ys_r = ys_r[::-1]

        M_x = (xs_l + xs_r) / 2
        M_y = (ys_l + ys_r) / 2

        p = scipy.misc.imread(self.phase[frame_idx])
        f = scipy.misc.imread(self.fluor[frame_idx])
        f_denoise = self.process_fluor(f)

        f2 = scipy.misc.imread(self.fluor2[frame_idx])  # f2 = ParA
        f2_denoise = self.process_fluor(f2)

        data = f, f_denoise, f2, f2_denoise
        mesh = xs_l, xs_r, ys_l, ys_r

        F, F_unsmoothed, F2, F2_unsmoothed = self.get_fluor_for_rib(
            data, mesh
        )

        # M = np.column_stack((M_x, M_y))
        i = np.array(range(len(F)))
        bg = f.mean()
        bg2 = f2.mean()

        # get peaks
        m = (F - bg).mean() - np.std(F - bg)
        m2 = (F2 - bg2).mean() - np.std(F2 - bg2)
        # s = np.std(F)

        # argrelextrema peak-finding method
        peaks = scipy.signal.argrelextrema(F - bg, np.greater_equal)[0]
        ParB_vals = [
            (i[_z], (F - bg)[_z]) for _z in peaks if (F - bg)[_z] > m
        ]

        # ParA peak is the maximum value
        _parA = np.array(F2).argmax()
        ParA_max = _parA, F2[_parA]

        # check distances between peaks
        if len(ParB_vals) > 1:
            # group peaks into multiples of 10 for x position
            # i.e. 0-9, 10-19, etc. are grouped together
            modval = 5
            modded = [(_i[0] // modval, (_i[0], _i[1])) for _i in ParB_vals]

            # rearrange flat list of modded groups into grouped list
            grouped = set(map(lambda x: x[0], modded))
            groups = []
            for group in grouped:
                out = []
                for mod_val in modded:
                    if mod_val[0] == group:
                        out.append(mod_val[1])
                groups.append(out)

            out = []
            for group in groups:
                if len(group) > 1:
#                    # average
#                    index = int(np.mean([_val[0] for _val in group]))
#                    out.append((index, group[0][1]))
                    # use highest intensity value of group
                    out.append(max(group, key=operator.itemgetter(1)))
                else:
                    out.append(group[0])
            ParB_vals = sorted(out, key=operator.itemgetter(0))

            # remove any spot that is within 2 pixels of a pole

            ParB_vals = [
                _i for _i in ParB_vals
                if self._pole_dist_check(_i, i, cell.length[0][0])
            ]

            # if more than 2 spots, select two with greatest intensity
#            if len(ParB_vals) > 2:
#                ParB_vals = sorted([
#                    ParB_vals.pop(ParB_vals.index(max(ParB_vals, key=operator.itemgetter(1)))),
#                    ParB_vals.pop(ParB_vals.index(max(ParB_vals, key=operator.itemgetter(1))))
#                ], key=operator.itemgetter(0))

#        # calculate ParA signal (f2)
#        # split cell into 8 segments
#        # determine total intensity of fluorescence in that region
#        num_ribs = len(cell.mesh)
#        interval = num_ribs / 8
#        seg_bounds = np.arange(
#            interval,
#            num_ribs + interval,
#            interval,
#            dtype=np.int
#        )
#        seg_polygons = []
#        for seg_bound in seg_bounds:
#            seg_mesh = cell.mesh[seg_bound - interval:seg_bound]
#            seg_xs_l = seg_mesh[:, 0]
#            seg_xs_r = seg_mesh[:, 2]
#            seg_ys_l = seg_mesh[:, 1]
#            seg_ys_r = seg_mesh[:, 3]
#            seg_mesh = seg_xs_l, seg_xs_r, seg_ys_l, seg_ys_r
#            _1, _2, seg_F2, _3 = self.get_fluor_for_rib(
#                data, seg_mesh
#            )
#            seg_total_F2 = np.sum(seg_F2)
#            seg_polygons.append(seg_total_F2)

        ParA_val = ((ParA_max[0] / i[-1]) * cell.length[0][0], ParA_max[1], cell.length[0][0])
        ParB_vals = [
            ((__[0] / i[-1]) * cell.length[0][0], __[1], cell.length[0][0]) for __ in ParB_vals
        ]

        if self.debug:
            plt.figure()
            ax = plt.subplot(231)
            plt.imshow(p, cmap=plt.cm.gray)
            # plt.plot(M_x, M_y, "r-")
            plt.plot(xs_l, ys_l, "w-", lw=0.5)
            plt.plot(xs_r, ys_r, "w-", lw=0.5)
#            _ = 0
#            while _ < xs_l.shape[0]:
#                plt.plot(
#                    (xs_l[_], xs_r[_]),
#                    (ys_l[_], ys_r[_]),
#                    "y-"
#                )
#                _ += 1
#
            for p in ParB_vals:
                x, y = M_x[p[0]], M_y[p[0]]
                plt.plot(
                    x, y, "r*"
                )
                x, y = M_x[ParA_max[0]], M_y[ParA_max[0]]
                plt.plot(
                    x, y, "y*"
                )

            plt.title("Phase")
            deaxis()

            plt.subplot(232, sharex=ax, sharey=ax)
            plt.imshow(f2, cmap=colourmap.cm)
            plt.plot(xs_l, ys_l, "w-", lw=0.5)
            plt.plot(xs_r, ys_r, "w-", lw=0.5)
            x, y = M_x[ParA_max[0]], M_y[ParA_max[0]]
            plt.plot(
                x, y, "w*"
            )
            plt.title("ParA")
            deaxis()

            plt.subplot(233, sharex=ax, sharey=ax)
            plt.imshow(f, cmap=colourmap.cm)
            plt.plot(xs_l, ys_l, "w-", lw=0.5)
            plt.plot(xs_r, ys_r, "w-", lw=0.5)

            for p in ParB_vals:
                x, y = M_x[p[0]], M_y[p[0]]
                plt.plot(
                    x, y, "w*"
                )
            plt.title("ParB")
            plt.xlim([0, f.shape[0]])
            plt.ylim([0, f.shape[1]])
            deaxis()

            plt.subplot(235)
            plt.plot(i, F2 - bg2, "k-")
            plt.plot(i, F2_unsmoothed - bg2, "k-", alpha=0.4)
            plt.plot(
                ParA_max[0], ParA_max[1] - bg2, "r."
            )
            plt.plot([i[0], i[-1]], [m2, m2])

            plt.subplot(236)
            plt.plot(i, F - bg, "k-")
            plt.plot(i, F_unsmoothed - bg, "k-", alpha=0.4)
            plt.plot([i[0], i[-1]], [m, m])
            # plt.plot([i[0], i[-1]], [m + s, m + s], "y-")

            for p in ParB_vals:
                plt.plot(
                    p[0], p[1], "r."
                )

            plt.show()

        return ParA_val, ParB_vals

    def _pole_dist_check(self, pos, arr, clen, threshold=2):
        p1_d = (pos[0] / arr[-1]) * clen
        p2_d = clen - p1_d
        return p1_d > threshold and p2_d > threshold

    def get_orientation(self, cell, prior):
        poles = cell.mesh[0, 0:2], cell.mesh[-1, 0:2]
        d1 = np.sqrt(
            ((poles[0][0] - prior[0][0]) ** 2) +
            ((poles[0][1] - prior[0][1]) ** 2)
        ) + np.sqrt(
            ((poles[1][0] - prior[1][0]) ** 2) +
            ((poles[1][1] - prior[1][1]) ** 2)
        )

        d2 = np.sqrt(
            ((poles[0][0] - prior[1][0]) ** 2) +
            ((poles[0][1] - prior[1][1]) ** 2)
        ) + np.sqrt(
            ((poles[1][0] - prior[0][0]) ** 2) +
            ((poles[1][1] - prior[0][1]) ** 2)
        )
        if d1 < d2:
            return True
        else:
            return False

    def _crop(self, im, xmin, xmax, ymin, ymax):
        return im[
            xmin:xmax,
            ymin:ymax
        ]

    def spot_finder(self, phase, fluor, fluor2, cell_lines):
        self.phase = phase
        self.fluor = fluor
        self.fluor2 = fluor2
        self.get_timings()
        cell_line_num = 1
        for cell_line in cell_lines:
            if os.path.exists("data/data-lineage{0}.pdf".format(cell_line_num)):
                print("Skipping cell lineage {0} of {1}".format(
                    cell_line_num, len(cell_lines)
                ))
                cell_line_num += 1
                continue
            L = []
            S_A = []
            S_B = []
            prior = None
            for cell in cell_line:
                L.append(cell.length[0][0])
                if prior:
                    orientation = self.get_orientation(cell, prior)
                else:
                    orientation = True
                cell.orientation = orientation
                spot_ParA, spots_ParB = self.get_spots(cell, orientation)
                S_A.append(spot_ParA)
                S_B.append(spots_ParB)
                if orientation:
                    prior = cell.mesh[0, 0:2], cell.mesh[-1, 0:2]
                else:
                    prior = cell.mesh[-1, 0:2], cell.mesh[0, 0:2]

            start = cell_line[0].frame - 1
            end = cell_line[-1].frame - 1
            t = np.array(self.T[start:end + 1])

            grid_width = len(S_A)
            fig = plt.figure(figsize=(grid_width * 15, 30))
            gs = gridspec.GridSpec(2, grid_width)

            # show cells
            frame_num = start + 1 - 1
            sp_num = 0
            while frame_num <= end:
                centre = cell_line[sp_num].centre
                rang = 40
                xmin = centre[0] - rang
                xmax = centre[0] + rang
                ymin = centre[1] - rang
                ymax = centre[1] + rang

                mesh = cell_line[sp_num].mesh
                if cell_line[sp_num].orientation:
                    M_x = (mesh[:, 0] + mesh[:, 2]) / 2
                    M_y = (mesh[:, 1] + mesh[:, 3]) / 2
                else:
                    M_x = (mesh[:, 0][::-1] + mesh[:, 2][::-1]) / 2
                    M_y = (mesh[:, 1][::-1] + mesh[:, 3][::-1]) / 2

                phase = scipy.misc.imread(self.phase[frame_num])
                parB = scipy.misc.imread(self.fluor[frame_num])
                parA = scipy.misc.imread(self.fluor2[frame_num])

                bg_parA = parA - parA.mean()
                bg_parA[bg_parA < 0] = np.NaN
                bg_parA = np.dstack((
                    bg_parA / np.nanmax(bg_parA),
                    np.zeros(parA.shape),
                    np.zeros(parA.shape),
                ))

                fig.add_subplot(gs[0, sp_num:sp_num + 1])
                plt.imshow(phase, cmap=plt.cm.gray, alpha=1)
                plt.imshow(bg_parA, alpha=.5)
                # plot cell outline
                plt.plot(mesh[:, 0], mesh[:, 1], "w-")
                plt.plot(mesh[:, 2], mesh[:, 3], "w-")
                # plot parA maximum
                x, y = M_x[S_A[sp_num][0]], M_y[S_A[sp_num][0]]
                plt.plot(x, y, "w*", ms=50)
                plt.xlim([xmin, xmax])
                plt.ylim([ymax, ymin])
                deaxis()

                bg_parB = parB - parB.mean()
                bg_parB[bg_parB < 0] = np.NaN
                bg_parB = np.dstack((
                    np.zeros(parB.shape),
                    bg_parB / np.nanmax(bg_parB),
                    np.zeros(parB.shape),
                ))

                fig.add_subplot(gs[1, sp_num:sp_num + 1])
                plt.imshow(phase, cmap=plt.cm.gray)
                plt.imshow(bg_parB, alpha=.5)
                plt.plot(mesh[:, 0], mesh[:, 1], "w-")
                plt.plot(mesh[:, 2], mesh[:, 3], "w-")
                spot_num = 1
                # spot_max = len(S_B[sp_num])
                for parB_spot in S_B[sp_num]:
                    x, y = M_x[parB_spot[0]], M_y[parB_spot[0]]
#                    if spot_max > 1:
#                        if spot_num == 1:
#                            #plt.plot(x, y, "r*", ms=50)
#                            plt.arrow(x + 10, y - 10, -5, 5, head_width=2, fc="r", ec="r")
#                        elif spot_num == spot_max:
#                            #plt.plot(x, y, "b*", ms=50)
#                            plt.arrow(x + 10, y - 10, -5, 5, head_width=2, fc="b", ec="b")
#                        else:
#                            plt.plot(x, y, "w*", ms=50)
#                    else:
#                        plt.plot(x, y, "w*", ms=50)
                    plt.plot(x, y, "w*", ms=50)

                    spot_num += 1
                plt.xlim([xmin, xmax])
                plt.ylim([ymax, ymin])
                deaxis()

                frame_num += 1
                sp_num += 1

            # gs.update(hspace=0)
            if not os.path.exists("data"):
                os.mkdir("data")
            plt.savefig("data/image-lineage{0}.pdf".format(cell_line_num))

            fig = plt.figure(figsize=(20, 10))
            gs = gridspec.GridSpec(2, 3)
            # plot cell lengths with cell-centre at 0
            L = np.array(L)

            # plt.subplot(231)
            fig.add_subplot(gs[0, 0])
            plt.plot(t, L / 2, "k-", lw=2)
            plt.plot(t, (L / 2) * -1, "k-", lw=2)

            spot1_ParA = []
            i = 0
            for tp in S_A:
                spot1_ParA.append((t[i], tp[0] - (tp[2] / 2)))
                i += 1
            spot1_ParA = np.array(spot1_ParA)

            plt.plot(spot1_ParA[:, 0], spot1_ParA[:, 1], "r-", lw=2)
            i = 0

            excel_wb = xlwt.Workbook()
            ws_parA = excel_wb.add_sheet("ParA")
            ws_parB = excel_wb.add_sheet("ParB")

            ws_parA.write(0, 0, "Time")
            ws_parA.write(0, 1, "Distance from top pole")
            ws_parA.write(0, 2, "Distance from midcell")
            ws_parA.write(0, 3, "Cell length")
            ws_parB.write(0, 1, "Cell length")
            ws_parA.write(0, 4, "Spot intensity")

            parAs = {}

            for s in S_A:
                midcell = s[2] / 2
                spot = s[0] - midcell
                plt.plot(
                    t[i],
                    spot,
                    "r.",
                    ms=10
                )
                ws_parA.write(i + 1, 0, int(t[i]))
                ws_parA.write(i + 1, 1, float(s[0]))
                ws_parA.write(i + 1, 2, float(spot))
                ws_parA.write(i + 1, 3, float(s[2]))
                ws_parB.write(i + 1, 1, float(s[2]))
                ws_parA.write(i + 1, 4, float(s[1]))
                parAs[t[i]] =  spot
                i += 1

            plt.ylabel(r"Distance from mid-cell (px)")
            plt.title("ParA")

            # plt.subplot(232)
            # fig.add_subplot(gs[1, 1])
            ax_parA = fig.add_subplot(gs[1, 0])
            plt.title("ParA maximum")
            plt.plot(spot1_ParA[:, 0], (L / 2) - spot1_ParA[:, 1], "b-", lw=2, label="Distance from top pole")
            plt.plot(spot1_ParA[:, 0], (L / 2) + spot1_ParA[:, 1], "r-", lw=2, label="Distance from bottom pole")
            #plt.legend(bbox_to_anchor=(1.65, 0.3))
            plt.xlabel("Time (min)")
            plt.ylabel("Distance (px)")

            ax_parB_mid = fig.add_subplot(gs[0, 1])
            plt.plot(t, L / 2, "k-", lw=2)
            plt.plot(t, -(L / 2), "k-", lw=2)

            # fake for legend
            plt.plot([0], [0], "b-", label="Distance from top pole")
            plt.plot([0], [0], "r-", label="Distance from bottom pole")
            plt.plot([0], [0], "k-", label="Distance from ParA focus")
            #plt.legend(bbox_to_anchor=(1.65, 0.3))
            plt.legend(bbox_to_anchor=(2, 0.1))

            spots_ParB = []
            i = 0
            for tp in S_B:
                if i > 0:
                    tp_clone = list(tp)
                    options = list(spots_ParB)
                    TRAVEL_THRESHOLD = 5.1
                    for opt in options:
                        last_added = opt.last()
                        distances = []
                        if len(tp_clone) == 0:
                            continue

                        for tp_idx in range(len(tp_clone)):
                            pos, inten, celllen = tp_clone.pop()
                            distances.append((
                                tp_idx, pos, inten, celllen,
                                np.sqrt(
                                    ((pos - (celllen / 2)) - last_added[1]) ** 2
                                )
                            ))
                        d = np.array(distances)
                        min_idx, min_pos, min_inten, min_celllen, min_dist = d[
                            np.argmin(d[:, 4])
                        ]
                        dd_idx = 0
                        for dd in distances:
                            if dd_idx == min_idx and min_dist < TRAVEL_THRESHOLD:
                                opt.append(
                                    t[i],
                                    min_pos - (min_celllen / 2),
                                    min_inten,
                                    min_celllen,
                                )
                            else:
                                tp_idx, pos, inten, celllen, dist = dd
                                tp_clone.append((
                                    pos,
                                    inten,
                                    celllen
                                ))
                            dd_idx += 1

                    # start new spot timelapses for unassigned foci
                    for pos, inten, celllen in tp_clone:
                        spots_ParB.append(SpotTimeLapse(
                            t[i],
                            pos - (celllen / 2),
                            inten,
                            celllen,
                        ))

                else:
                    # start new spot timelapses
                    for pos, inten, celllen in tp:
                        spots_ParB.append(SpotTimeLapse(
                            t[i],
                            pos - (celllen / 2),
                            inten,
                            celllen,
                        ))

                i += 1

            ws_parB.write(0, 0, "Time")
            i = 1
            time_dict = {}
            for time_ in t:
                ws_parB.write(i, 0, int(time_))
                time_dict[float(time_)] = i
                i += 1

            rmax = max(time_dict.values())
            ws_parB.write(rmax + 2, 0, "Intensity mean:")
            ws_parB.write(rmax + 3, 0, "Intensity SEM:")
            ws_parB.write(rmax + 4, 0, "Distance from ParA (mean):")
            ws_parB.write(rmax + 5, 0, "Distance from ParA (SEM):")

            col = 2
            spotnum = 1
            for x in spots_ParB:
                s = x.spots(False)
                plt.plot(s[:, 0], s[:, 1], lw=2, marker="o", markeredgecolor="k")
                ws_parB.write(0, col, "Distance from mid-cell (Spot {0})".format(spotnum))
                ws_parB.write(0, col + 1, "Intensity (Spot {0})".format(spotnum))
                ws_parB.write(0, col + 2, "Distance from ParA (Spot {0})".format(spotnum))

                dparA = []
                for spot in s:
                    r = time_dict[spot[0]]
                    ws_parB.write(r, col, float(spot[1]))
                    ws_parB.write(r, col + 1, float(spot[2]))
                    dpA = parAs[spot[0]] - spot[1]
                    dparA.append(dpA)
                    ws_parB.write(r, col + 2, float(dpA))

                # intensity mean and SEM for spot lineage
                x.intensity_mean = s[:, 2].mean()
                x.intensity_sem = s[:, 2].std() / np.sqrt(len(s[:, 1]))
                ws_parB.write(rmax + 2, col + 1, float(x.intensity_mean))
                ws_parB.write(rmax + 3, col + 1, float(x.intensity_sem))

                # distance from ParA mean and SEM for spot lineage
                x.parA_d = dparA
                x.parA_dmean = np.mean(dparA)
                x.parA_dsem = np.std(dparA) / np.sqrt(len(dparA))
                ws_parB.write(rmax + 4, col + 2, float(x.parA_dmean))
                ws_parB.write(rmax + 5, col + 2, float(x.parA_dsem))

                col += 3
                spotnum += 1

            plt.ylabel(r"Distance from mid-cell (px)")
            plt.xlabel("Time (min)")
            plt.title("ParB")

            # plot spot lineage which is on average closer to ParA
            filtered = [x for x in spots_ParB if len(x) > 4]
            if len(filtered) > 0:
                ax_parB_closest = fig.add_subplot(gs[1, 1], sharex=ax_parA, sharey=ax_parA)
                dmin = min(
                    filtered,
                    key=lambda x: np.abs(x.parA_dmean)
                )
                s = dmin.spots(False)
                # from midcell: s[:, 1]
                dpol_t = (dmin.len() / 2) - s[:, 1]
                dpol_b = (dmin.len() / 2) + s[:, 1]

                plt.plot(s[:, 0], dpol_t, marker=".", lw=2, mec="k", ms=10, label="Distance from top pole")
                plt.plot(s[:, 0], dpol_b, marker=".", lw=2, mec="k", ms=10, label="Distance from bottom pole")
                plt.plot(s[:, 0], dmin.parA_d, marker=".", lw=2, mec="k", ms=10, label="Distance from ParA focus")

                plt.plot(plt.xlim(), [0, 0], "k--")

    #            plt.plot(plt.xlim(), [x.parA_dmean, x.parA_dmean], "k--", lw=2)

                plt.title("ParB Spot {0} (dmin)".format(dmin.spotnum))
                plt.ylabel("Distance (px)")
                plt.xlabel("Time (min)")

            # plot two spot lineages with highest intensity
                imax = max(spots_ParB, key=lambda x: x.intensity_mean)
                if imax.id != dmin.id:
                    fig.add_subplot(gs[1, 2], sharex=ax_parB_closest, sharey=ax_parA)
                    s = imax.spots(False)
                    dpol_t = (imax.len() / 2) - s[:, 1]
                    dpol_b = (imax.len() / 2) + s[:, 1]

                    plt.plot(s[:, 0], dpol_t, marker=".", lw=2, mec="k", ms=10, label="Distance from top pole")
                    plt.plot(s[:, 0], dpol_b, marker=".", lw=2, mec="k", ms=10, label="Distance from bottom pole")
                    plt.plot(s[:, 0], imax.parA_d, marker=".", lw=2, mec="k", ms=10, label="Distance from ParA focus")

                    plt.plot(plt.xlim(), [0, 0], "k--")

                    plt.title("ParB Spot {0} (imax)".format(imax.spotnum))
                    plt.ylabel("Distance (px)")
                    plt.xlabel("Time (min)")
                    plt.legend(bbox_to_anchor=(0.8, 1.35))
                else:
                    plt.legend(bbox_to_anchor=(1.65, 1))
            else:
                ax_parA.legend(bbox_to_anchor=(1.65, 1))

            plt.tight_layout()
            plt.savefig("data/data-lineage{0}.pdf".format(cell_line_num))

            excel_wb.save("data/lineage{0}.xls".format(cell_line_num))
            print("Processed cell lineage {0} of {1}".format(
                cell_line_num, len(cell_lines)
            ))
            cell_line_num += 1


if __name__ == "__main__":
    sns.set_style("white")
    sns.set_context("talk")
    if "-d" in sys.argv:
        debug = True
    else:
        debug = False
    A = Analysis(debug=debug)
    A.apply_alignments()

    cell_lines = []
    initial_cells = A.frames[0].cells
    for f in initial_cells:
        lin = [f]
        while True:
            if type(f.children) is list:
                initial_cells.append(A.frames.cell(f.children[0]))
                initial_cells.append(A.frames.cell(f.children[1]))
                break
            elif f.children:
                c = f.children
                c = A.frames.cell(c)
                lin.append(c)
                f = c
            else:
                break
        cell_lines.append(lin)

#    final_cells = A.frames[-1].cells
#    cell_lines = []
#    for f in final_cells:
#        lin = [f]
#        while True:
#            if not f.parent:
#                break
#            p = f.parent
#            p = A.frames.cell(p)
#            lin.insert(0, p)
#            f = p
#        cell_lines.append(lin)

    phase = sorted(glob.glob("B/*.tif"))
    parA = sorted(glob.glob("F1/*.tif"))
    parB = sorted(glob.glob("F2/*.tif"))

    A.spot_finder(phase, parB, parA, cell_lines)
